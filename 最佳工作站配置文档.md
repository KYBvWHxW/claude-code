
 **Claude Code Hooks + pytest + Schemathesis 的最佳实践** 和 **Python + LangGraph + OpenRouter + Gradio + Fly.io 轻量全栈方案** 整合成一个完整的 **最佳工作站配置文档 (Markdown)**。

---

# 🚀 Claude Code 最佳工作站配置指南

本指南整合两大部分：

1. **Claude Code Hooks + pytest + Schemathesis 的测试最佳实践**
2. **Python + LangGraph + OpenRouter + Gradio + Fly.io 轻量全栈开发方案**

目标：打造一个 **开发 → 测试 → 部署 → 在线交互** 的闭环工作站。

---

## 1. 🔧 Claude Code Hooks + pytest + Schemathesis

### 1.1 Hooks 背景

Claude Code 支持 **hooks**（钩子），在事件发生后自动执行命令。

* **PostToolUse**：在 Claude 执行 Write/Edit/MultiEdit 之后触发。
* **退出码语义**：

  * `0`：成功，继续
  * `1`：仅提示，不阻断
  * `2`：阻断并把 `stderr` 回传给 Claude，模型会尝试修复

---

### 1.2 通用 `.claude/settings.json`

在项目根目录新建 `.claude/settings.json`：

```json
{
  "hooks": {
    "PostToolUse": [
      {
        "matcher": "Write|Edit|MultiEdit",
        "hooks": [
          {
            "type": "command",
            "command": "python3 - <<'PY'\nimport json, os, sys, subprocess, shlex\ninp=json.load(sys.stdin)\nfp=inp.get('tool_input',{}).get('file_path','') or ''\nroot=os.getcwd()\n\n# 工具函数\ndef run(cmd):\n    print('Running:', ' '.join(map(shlex.quote, cmd)))\n    p=subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)\n    return p.returncode, p.stdout, p.stderr\n\ndef fail(msg, out='', err=''):\n    sys.stderr.write(msg+'\\n')\n    if out: sys.stderr.write(out+'\\n')\n    if err: sys.stderr.write(err+'\\n')\n    sys.exit(2)\n\nran_any=False\n\n# Node 项目\nif os.path.exists(os.path.join(root,'package.json')) and any(fp.endswith(ext) for ext in ('.js','.jsx','.ts','.tsx','.mjs','.cjs')):\n    code,out,err=run([\"npm\",\"test\",\"--silent\"])\n    if code==0:\n        print(out); ran_any=True\n    else:\n        fail('npm tests failed', out, err)\n\n# Python 项目\nif any(fp.endswith(ext) for ext in ('.py','.pyx','.pyi')) or os.path.exists(os.path.join(root,'pyproject.toml')):\n    code,out,err=run([\"pytest\",\"-q\"])\n    if code==0:\n        print(out); ran_any=True\n    else:\n        fail('pytest failed', out, err)\n\n# API 层 Schemathesis\napi_touched = (\n    fp.endswith(('openapi.yaml','openapi.yml','schema.graphql')) or\n    fp.startswith(('openapi/','schemas/','api/','routes/'))\n)\nif api_touched:\n    schema_path = 'openapi.yaml' if os.path.exists('openapi.yaml') else None\n    if schema_path:\n        cmd=[\"schemathesis\",\"run\",\"--max-examples\",\"50\",\"--validate-schema\",\"--continue-on-failure\", schema_path]\n        code,out,err=run(cmd)\n        if code==0:\n            print(out)\n        else:\n            fail('Schemathesis failures', out, err)\n\nif not ran_any and not api_touched:\n    sys.exit(0)\n\nsys.exit(0)\nPY"
          }
        ]
      }
    ]
  }
}
```

---

### 1.3 项目侧配置

#### Python (pytest)

`pyproject.toml`

```toml
[tool.pytest.ini_options]
addopts = "-q"
testpaths = ["tests"]
```

#### API Schemathesis

CLI 模式：

```bash
pip install -U schemathesis
schemathesis run --max-examples 50 --validate-schema openapi.yaml
```

Pytest 集成：

```python
# tests/test_api_schema.py
import schemathesis
schema = schemathesis.from_path("openapi.yaml")

@schema.parametrize()
def test_api(case):
    case.call_and_validate()
```

运行：

```bash
pytest -q -k schemathesis
```

---

### 1.4 工作流

1. Claude 写/改代码 → **Hooks 自动触发测试**
2. **单测/集成测试 (pytest/npm test)** → 确认功能正确
3. **API 改动 → Schemathesis 快速集** → 检查边界用例
4. **失败 → Claude 收到错误日志并自动修复**

---

## 2. 🌐 Python + LangGraph + OpenRouter + Gradio + Fly.io

### 2.1 项目结构

```
your-app/
├─ app.py              # FastAPI + Gradio
├─ graph.py            # LangGraph 流程
├─ llm.py              # OpenRouter 客户端
├─ requirements.txt
├─ Dockerfile
└─ fly.toml
```

### 2.2 llm.py（OpenRouter）

```python
import os
from openai import OpenAI

client = OpenAI(
    base_url="https://openrouter.ai/api/v1",
    api_key=os.environ["OPENROUTER_API_KEY"],
)

def chat(messages):
    extra_headers = {
        "HTTP-Referer": os.getenv("APP_URL", "http://localhost:7860"),
        "X-Title": os.getenv("APP_TITLE", "LangGraph Gradio Starter"),
    }
    resp = client.chat.completions.create(
        model=os.getenv("OPENROUTER_MODEL", "openai/gpt-4o-mini"),
        messages=messages,
        extra_headers=extra_headers,
    )
    return resp.choices[0].message.content
```

### 2.3 graph.py（LangGraph）

```python
from typing import TypedDict, List, Dict, Any
from langgraph.graph import StateGraph, START, END
from llm import chat

class State(TypedDict):
    messages: List[Dict[str, Any]]

def llm_node(state: State) -> State:
    answer = chat(state["messages"])
    return {"messages": state["messages"] + [{"role": "assistant", "content": answer}]}

def build_graph():
    g = StateGraph(State)
    g.add_node("llm", llm_node)
    g.add_edge(START, "llm")
    g.add_edge("llm", END)
    return g.compile()
```

### 2.4 app.py（FastAPI + Gradio）

```python
import gradio as gr
from fastapi import FastAPI
from starlette.middleware.cors import CORSMiddleware
from graph import build_graph

graph = build_graph()

def respond(user_input, history):
    messages = [{"role": "system", "content": "You are a helpful assistant."}]
    for h in history:
        messages += [{"role": "user", "content": h[0]}, {"role": "assistant", "content": h[1]}]
    messages.append({"role": "user", "content": user_input})
    final_state = graph.invoke({"messages": messages})
    return final_state["messages"][-1]["content"]

ui = gr.ChatInterface(fn=respond, title="LangGraph + OpenRouter", fill_height=True)

app = FastAPI()
app.add_middleware(CORSMiddleware, allow_origins=["*"], allow_methods=["*"], allow_headers=["*"])
app = gr.mount_gradio_app(app, ui, path="/")
```

### 2.5 部署 (Fly.io)

`Dockerfile`

```dockerfile
FROM python:3.11-slim
WORKDIR /app
RUN pip install --no-cache-dir --upgrade pip
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt
COPY . .
EXPOSE 8080
CMD ["uvicorn", "app:app", "--host", "0.0.0.0", "--port", "8080"]
```

`fly.toml`

```toml
app = "langgraph-gradio-starter"
primary_region = "sin"

[build]
  dockerfile = "Dockerfile"

[env]
  APP_URL = "https://langgraph-gradio-starter.fly.dev"

[[services]]
  internal_port = 8080
  processes = ["app"]
  protocol = "tcp"
  [[services.ports]]
    handlers = ["http"]
    port = 80
  [[services.ports]]
    handlers = ["tls", "http"]
    port = 443
```

部署：

```bash
flyctl launch --no-deploy
flyctl secrets set OPENROUTER_API_KEY=sk-...
flyctl deploy
```

---

# ✅ 最佳工作站状态

1. **Claude Code Hooks**：自动测试 & 反馈闭环
2. **pytest + Schemathesis**：保证功能正确 + API 鲁棒性
3. **LangGraph**：编排复杂对话 & 有状态 Agent
4. **OpenRouter**：多模型统一 API 接入
5. **Gradio + FastAPI**：交互 UI + Web 服务
6. **Fly.io**：快速部署、全球可访问

---



